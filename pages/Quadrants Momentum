from __future__ import annotations
import streamlit as st
import pandas as pd
import numpy as np
import os
import joblib
import plotly.graph_objects as go
import re
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
from datetime import datetime
import math
import plotly.graph_objects as go # Importado para o final do script
import warnings
warnings.filterwarnings("ignore") # Para evitar warnings de libs como Pandas/Sklearn no Streamlit

st.set_page_config(page_title="AnÃ¡lise de Quadrantes - Bet Indicator", layout="wide")
st.title("ğŸ¯ AnÃ¡lise de 16 Quadrantes - ML AvanÃ§ado (Aggression x Momentum)")

# ---------------- ConfiguraÃ§Ãµes ----------------
PAGE_PREFIX = "QuadrantesML_Momentum"
GAMES_FOLDER = "GamesDay"
LIVESCORE_FOLDER = "LiveScore"
EXCLUDED_LEAGUE_KEYWORDS = ["cup", "copas", "uefa", "afc", "sudamericana", "copa", "trophy"]

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
MODELS_FOLDER = os.path.join(BASE_DIR, "Models")
os.makedirs(MODELS_FOLDER, exist_ok=True)

# ---------------- CONFIGURAÃ‡Ã•ES LIVE SCORE ----------------
# ... (FunÃ§Ãµes setup_livescore_columns, preprocess_df, load_all_games, filter_leagues, etc. permanecem as mesmas)
# ... (Omitidas para brevidade, mas vocÃª deve manter as suas)

def setup_livescore_columns(df):
Â  Â  """Garante que as colunas do Live Score existam no DataFrame"""
Â  Â  if 'Goals_H_Today' not in df.columns:
Â  Â  Â  Â  df['Goals_H_Today'] = np.nan
Â  Â  if 'Goals_A_Today' not in df.columns:
Â  Â  Â  Â  df['Goals_A_Today'] = np.nan
Â  Â  if 'Home_Red' not in df.columns:
Â  Â  Â  Â  df['Home_Red'] = np.nan
Â  Â  if 'Away_Red' not in df.columns:
Â  Â  Â  Â  df['Away_Red'] = np.nan
Â  Â  return df

def preprocess_df(df: pd.DataFrame) -> pd.DataFrame:
Â  Â  df = df.copy()
Â  Â  if "Goals_H_FT_x" in df.columns:
Â  Â  Â  Â  df = df.rename(columns={"Goals_H_FT_x": "Goals_H_FT", "Goals_A_FT_x": "Goals_A_FT"})
Â  Â  elif "Goals_H_FT_y" in df.columns:
Â  Â  Â  Â  df = df.rename(columns={"Goals_H_FT_y": "Goals_H_FT", "Goals_A_FT_y": "Goals_A_FT"})
Â  Â  return df

def load_all_games(folder: str) -> pd.DataFrame:
Â  Â  files = [f for f in os.listdir(folder) if f.endswith(".csv")]
Â  Â  if not files:
Â  Â  Â  Â  return pd.DataFrame()
Â  Â  dfs = [preprocess_df(pd.read_csv(os.path.join(folder, f))) for f in files]
Â  Â  return pd.concat(dfs, ignore_index=True)

def filter_leagues(df: pd.DataFrame) -> pd.DataFrame:
Â  Â  if df.empty or "League" not in df.columns:
Â  Â  Â  Â  return df
Â  Â  pattern = "|".join(EXCLUDED_LEAGUE_KEYWORDS)
Â  Â  return df[~df["League"].str.lower().str.contains(pattern, na=False)].copy()

def calc_handicap_result(margin, asian_line_str, invert=False):
Â  Â  """Retorna mÃ©dia de pontos por linha (1 win, 0.5 push, 0 loss)"""
Â  Â  if pd.isna(asian_line_str):
Â  Â  Â  Â  return np.nan
Â  Â  if invert:
Â  Â  Â  Â  margin = -margin
Â  Â  try:
Â  Â  Â  Â  parts = [float(x) for x in str(asian_line_str).split('/')]
Â  Â  except:
Â  Â  Â  Â  return np.nan
Â  Â  results = []
Â  Â  for line in parts:
Â  Â  Â  Â  if margin > line:
Â  Â  Â  Â  Â  Â  results.append(1.0)
Â  Â  Â  Â  elif margin == line:
Â  Â  Â  Â  Â  Â  results.append(0.5)
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  results.append(0.0)
Â  Â  return np.mean(results)

def convert_asian_line_to_decimal(line_str):
Â  Â  """Converte qualquer formato de Asian Line para valor decimal Ãºnico"""
Â  Â  if pd.isna(line_str) or line_str == "":
Â  Â  Â  Â  return None
Â  Â Â 
Â  Â  try:
Â  Â  Â  Â  line_str = str(line_str).strip()
Â  Â  Â  Â  # Se nÃ£o tem "/" Ã© valor Ãºnico
Â  Â  Â  Â  if "/" not in line_str:
Â  Â  Â  Â  Â  Â  return float(line_str)
Â  Â  Â  Â  # Se tem "/" Ã© linha fracionada - calcular mÃ©dia
Â  Â  Â  Â  parts = [float(x) for x in line_str.split("/")]
Â  Â  Â  Â  return sum(parts) / len(parts)
Â  Â  except (ValueError, TypeError):
Â  Â  Â  Â  return None

# ---------------- Carregar Dados (mantido o seu fluxo) ----------------

st.info("ğŸ“‚ Carregando dados para anÃ¡lise de 16 quadrantes...")

# SeleÃ§Ã£o de arquivo do dia
files = sorted([f for f in os.listdir(GAMES_FOLDER) if f.endswith(".csv")])
if not files:
Â  Â  st.warning("No CSV files found in GamesDay folder.")
Â  Â  st.stop()

options = files[-7:] if len(files) >= 7 else files
selected_file = st.selectbox("Select Matchday File:", options, index=len(options)-1)

date_match = re.search(r"\d{4}-\d{2}-\d{2}", selected_file)
selected_date_str = date_match.group(0) if date_match else datetime.now().strftime("%Y-%m-%d")

# Jogos do dia
games_today = pd.read_csv(os.path.join(GAMES_FOLDER, selected_file))
games_today = filter_leagues(games_today)

# FunÃ§Ã£o de Live Score (mantida)
def load_and_merge_livescore(games_today, selected_date_str):
    # ... (cÃ³digo da sua funÃ§Ã£o load_and_merge_livescore)
    livescore_file = os.path.join(LIVESCORE_FOLDER, f"Resultados_RAW_{selected_date_str}.csv")
    games_today = setup_livescore_columns(games_today)
    if os.path.exists(livescore_file):
        st.info(f"ğŸ“¡ LiveScore file found: {livescore_file}")
        results_df = pd.read_csv(livescore_file)
        results_df = results_df[~results_df['status'].isin(['Cancel', 'Postp.'])]
        required_cols = ['game_id', 'status', 'home_goal', 'away_goal', 'home_red', 'away_red']
        missing_cols = [col for col in required_cols if col not in results_df.columns]
        if missing_cols:
            st.error(f"âŒ LiveScore file missing columns: {missing_cols}")
            return games_today
        else:
            games_today = games_today.merge(
                results_df,
                left_on='Id',
                right_on='game_id',
                how='left',
                suffixes=('', '_RAW')
            )
            games_today['Goals_H_Today'] = games_today['home_goal']
            games_today['Goals_A_Today'] = games_today['away_goal']
            games_today.loc[games_today['status'] != 'FT', ['Goals_H_Today', 'Goals_A_Today']] = np.nan
            games_today['Home_Red'] = games_today['home_red']
            games_today['Away_Red'] = games_today['away_red']
            st.success(f"âœ… LiveScore merged: {len(results_df)} games loaded")
            return games_today
    else:
        st.warning(f"âš ï¸ No LiveScore file found for: {selected_date_str}")
        return games_today

# Aplicar Live Score
games_today = load_and_merge_livescore(games_today, selected_date_str)

# HistÃ³rico consolidado
history = filter_leagues(load_all_games(GAMES_FOLDER))
history = history.dropna(subset=["Goals_H_FT", "Goals_A_FT", "Asian_Line"]).copy()

# ---------------- CONVERSÃƒO ASIAN LINE E FILTROS (mantido) ----------------
# Aplicar conversÃ£o no histÃ³rico e jogos de hoje
history['Asian_Line_Decimal'] = history['Asian_Line'].apply(convert_asian_line_to_decimal)
games_today['Asian_Line_Decimal'] = games_today['Asian_Line'].apply(convert_asian_line_to_decimal)

# Filtrar apenas jogos com linha vÃ¡lida no histÃ³rico
history = history.dropna(subset=['Asian_Line_Decimal'])

# Filtro anti-leakage temporal
if "Date" in history.columns:
Â  Â  try:
Â  Â  Â  Â  selected_date = pd.to_datetime(selected_date_str)
Â  Â  Â  Â  history["Date"] = pd.to_datetime(history["Date"], errors="coerce")
Â  Â  Â  Â  history = history[history["Date"] < selected_date].copy()
Â  Â  Â  Â  st.info(f"ğŸ“Š Treinando com {len(history)} jogos anteriores a {selected_date_str}")
Â  Â  except Exception as e:
Â  Â  Â  Â  st.error(f"Erro ao aplicar filtro temporal: {e}")

# Targets AH histÃ³ricos
history["Margin"] = history["Goals_H_FT"] - history["Goals_A_FT"]
history["Target_AH_Home"] = history.apply(
Â  Â  lambda r: 1 if calc_handicap_result(r["Margin"], r["Asian_Line"], invert=False) > 0.5 else 0, axis=1
)

# ---------------- NOVO SISTEMA DE 16 QUADRANTES (AGGRESSION X MOMENTUM) ----------------
st.markdown("## ğŸ¯ Sistema de 16 Quadrantes (Aggression x Momentum)")

# *** AJUSTE PRINCIPAL: REDEFINIÃ‡ÃƒO DOS QUADRANTES PARA O EIXO Y (MOMENTUM) ***
QUADRANTES_MOMENTUM_16 = {
Â  Â  # O Eixo Y (M) agora usa Z-Scores de -3.5 a 3.5. Vamos usar faixas de Z-Score:
Â  Â  # M_MU = Momentum Muito Alto (M > 1.5)
Â  Â  # M_F = Momentum Forte (1.5 > M > 0.5)
Â  Â  # M_M = Momentum Moderado (0.5 > M > -0.5)
Â  Â  # M_N = Momentum Negativo (M < -0.5)

Â  Â  # ğŸ”µ QUADRANTE 1-4: FORTE FAVORITO (Aggression +0.75 a +1.0)
Â  Â  1: {"nome": "Fav Forte M_Muito Alto", "agg_min": 0.75, "agg_max": 1.0, "m_min": 1.5, "m_max": 3.5},
Â  Â  2: {"nome": "Fav Forte M_Forte",Â  Â  Â  "agg_min": 0.75, "agg_max": 1.0, "m_min": 0.5, "m_max": 1.5},
Â  Â  3: {"nome": "Fav Forte M_Moderado",Â  Â "agg_min": 0.75, "agg_max": 1.0, "m_min": -0.5, "m_max": 0.5},
Â  Â  4: {"nome": "Fav Forte M_Negativo",Â  Â "agg_min": 0.75, "agg_max": 1.0, "m_min": -3.5, "m_max": -0.5}, # Combina as duas faixas negativas

Â  Â  # ğŸŸ¢ QUADRANTE 5-8: FAVORITO MODERADO (Aggression +0.25 a +0.75)
Â  Â  5: {"nome": "Fav Moderado M_Muito Alto", "agg_min": 0.25, "agg_max": 0.75, "m_min": 1.5, "m_max": 3.5},
Â  Â  6: {"nome": "Fav Moderado M_Forte",Â  Â  Â  "agg_min": 0.25, "agg_max": 0.75, "m_min": 0.5, "m_max": 1.5},
Â  Â  7: {"nome": "Fav Moderado M_Moderado",Â  Â "agg_min": 0.25, "agg_max": 0.75, "m_min": -0.5, "m_max": 0.5},
Â  Â  8: {"nome": "Fav Moderado M_Negativo",Â  Â "agg_min": 0.25, "agg_max": 0.75, "m_min": -3.5, "m_max": -0.5},

Â  Â  # ğŸŸ¡ QUADRANTE 9-12: UNDERDOG MODERADO (Aggression -0.75 a -0.25)
Â  Â  9: {"nome": "Under Moderado M_Positivo",Â  "agg_min": -0.75, "agg_max": -0.25, "m_min": 0.5, "m_max": 3.5}, # Combina as duas faixas positivas
Â  Â  10: {"nome": "Under Moderado M_Moderado", "agg_min": -0.75, "agg_max": -0.25, "m_min": -0.5, "m_max": 0.5},
Â  Â  11: {"nome": "Under Moderado M_Forte Neg.", "agg_min": -0.75, "agg_max": -0.25, "m_min": -1.5, "m_max": -0.5},
Â  Â  12: {"nome": "Under Moderado M_Muito Neg.", "agg_min": -0.75, "agg_max": -0.25, "m_min": -3.5, "m_max": -1.5},

Â  Â  # ğŸ”´ QUADRANTE 13-16: FORTE UNDERDOG (Aggression -1.0 a -0.75)
Â  Â  13: {"nome": "Under Forte M_Positivo",Â  Â  Â  "agg_min": -1.0, "agg_max": -0.75, "m_min": 0.5, "m_max": 3.5},
Â  Â  14: {"nome": "Under Forte M_Moderado",Â  Â  Â  "agg_min": -1.0, "agg_max": -0.75, "m_min": -0.5, "m_max": 0.5},
Â  Â  15: {"nome": "Under Forte M_Forte Neg.",Â  Â  "agg_min": -1.0, "agg_max": -0.75, "m_min": -1.5, "m_max": -0.5},
Â  Â  16: {"nome": "Under Forte M_Muito Neg.",Â  Â  "agg_min": -1.0, "agg_max": -0.75, "m_min": -3.5, "m_max": -1.5}
}

def classificar_quadrante_momentum_16(agg, momentum):
Â  Â  """Classifica Aggression e Momentum (M) em um dos 16 quadrantes"""
Â  Â  if pd.isna(agg) or pd.isna(momentum):
Â  Â  Â  Â  return 0Â  # Neutro/Indefinido
Â  Â Â 
Â  Â  for quadrante_id, config in QUADRANTES_MOMENTUM_16.items():
Â  Â  Â  Â  agg_ok = (config['agg_min'] <= agg <= config['agg_max'])
Â  Â  Â  Â  # Ajustado para 'm_min' e 'm_max'
Â  Â  Â  Â  m_ok = (config['m_min'] <= momentum <= config['m_max'])
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  if agg_ok and m_ok:
Â  Â  Â  Â  Â  Â  return quadrante_id
Â  Â Â 
Â  Â  return 0Â  # Caso nÃ£o se enquadre em nenhum quadrante

# Aplicar classificaÃ§Ã£o aos dados (assumindo 'Aggression_Home' e 'Aggression_Away' jÃ¡ existem)
# Assumindo que as colunas M_H e M_A mapeiam para Home e Away, respectivamente
games_today['Quadrante_Home'] = games_today.apply(
Â  Â  lambda x: classificar_quadrante_momentum_16(x.get('Aggression_Home'), x.get('M_H')), axis=1
)
games_today['Quadrante_Away'] = games_today.apply(
Â  Â  lambda x: classificar_quadrante_momentum_16(x.get('Aggression_Away'), x.get('M_A')), axis=1
)

history['Quadrante_Home'] = history.apply(
Â  Â  lambda x: classificar_quadrante_momentum_16(x.get('Aggression_Home'), x.get('M_H')), axis=1
)
history['Quadrante_Away'] = history.apply(
Â  Â  lambda x: classificar_quadrante_momentum_16(x.get('Aggression_Away'), x.get('M_A')), axis=1
)
st.info(f"ğŸ“Š Quadrantes classificados usando Aggression e Momentum (M)")


# ---------------- CÃLCULO DE DISTÃ‚NCIAS (ADAPTADO PARA MOMENTUM) ----------------
def calcular_distancias_quadrantes(df):
Â  Â  """Calcula distÃ¢ncia, separaÃ§Ã£o mÃ©dia e Ã¢ngulo entre os pontos Home e Away (Agg x M)."""
Â  Â  df = df.copy()
Â  Â  # Usando M_H e M_A no lugar de HandScore_Home/Away
Â  Â  if all(col in df.columns for col in ['Aggression_Home', 'Aggression_Away', 'M_H', 'M_A']):
Â  Â  Â  Â  dx = df['Aggression_Home'] - df['Aggression_Away']
Â  Â  Â  Â  dy = df['M_H'] - df['M_A'] # DiferenÃ§a no Z-Score
Â  Â  Â  Â  # A escala visual ajustada Ã© crÃ­tica. 
Â  Â  Â  Â  # O Aggression (x) vai de -1 a 1 (amplitude 2). O Momentum (y) vai de -3.5 a 3.5 (amplitude 7).
Â  Â  Â  Â  # Vamos dar um peso um pouco menor para o eixo Y para equilibrar os eixos.
Â  Â  Â  Â  df['Quadrant_Dist'] = np.sqrt(dx**2 + (dy/3.5)**2) * 5 # Normalizado por 3.5 e escalado por 5
Â  Â  Â  Â  df['Quadrant_Separation'] = dy * 10 + dx * 20 # CombinaÃ§Ã£o linear para separar
Â  Â  Â  Â  df['Quadrant_Angle'] = np.degrees(np.arctan2(dy, dx))
Â  Â  else:
Â  Â  Â  Â  st.warning("âš ï¸ Colunas Aggression/M_H/M_A nÃ£o encontradas para calcular as distÃ¢ncias.")
Â  Â  Â  Â  df['Quadrant_Dist'] = np.nan
Â  Â  Â  Â  df['Quadrant_Separation'] = np.nan
Â  Â  Â  Â  df['Quadrant_Angle'] = np.nan
Â  Â  return df

# Aplicar ao games_today
games_today = calcular_distancias_quadrantes(games_today)
history = calcular_distancias_quadrantes(history) # Aplicar no histÃ³rico tambÃ©m

# ---------------- VISUALIZAÃ‡ÃƒO DOS 16 QUADRANTES (ADAPTADO) ----------------
@st.cache_resource
def plot_quadrantes_16(df, side="Home"):
Â  Â  """Plot dos 16 quadrantes com cores e anotaÃ§Ãµes (Aggression x Momentum)"""
Â  Â  fig, ax = plt.subplots(figsize=(14, 10))
Â  Â Â 
Â  Â  # Definir cores por categoria (mantido o esquema de cores)
Â  Â  cores_categorias = {
Â  Â  Â  Â  'Fav Forte': 'lightcoral',
Â  Â  Â  Â  'Fav Moderado': 'lightpink',Â 
Â  Â  Â  Â  'Under Moderado': 'lightblue',
Â  Â  Â  Â  'Under Forte': 'lightsteelblue'
Â  Â  }
Â  Â Â 
Â  Â  # Plotar cada ponto com cor da categoria
Â  Â  for quadrante_id in range(1, 17):
Â  Â  Â  Â  mask = df[f'Quadrante_{side}'] == quadrante_id
Â  Â  Â  Â  if mask.any():
Â  Â  Â  Â  Â  Â  # Usa o novo dicionÃ¡rio
Â  Â  Â  Â  Â  Â  categoria = QUADRANTES_MOMENTUM_16[quadrante_id]['nome'].split()[0] + ' ' + QUADRANTES_MOMENTUM_16[quadrante_id]['nome'].split()[1]
Â  Â  Â  Â  Â  Â  cor = cores_categorias.get(categoria, 'gray')
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  x = df.loc[mask, f'Aggression_{side}']
Â  Â  Â  Â  Â  Â  # Eixo Y agora Ã© M_H ou M_A
Â  Â  Â  Â  Â  Â  y = df.loc[mask, f'M_{side[0]}']
Â  Â  Â  Â  Â  Â  ax.scatter(x, y, c=cor,Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  label=QUADRANTES_MOMENTUM_16[quadrante_id]['nome'],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  alpha=0.7, s=50)
Â  Â Â 
Â  Â  # Linhas divisÃ³rias dos quadrantes (Aggression)
Â  Â  for x in [-0.75, -0.25, 0.25, 0.75]:
Â  Â  Â  Â  ax.axvline(x=x, color='black', linestyle='--', alpha=0.3)
Â  Â  ax.axvline(x=0, color='black', linestyle='-', alpha=0.5)
Â  Â Â 
Â  Â  # Linhas divisÃ³rias dos quadrantes (MOMENTUM)Â Â 
Â  Â  # Novas linhas baseadas no Z-Score: -1.5, -0.5, 0.5, 1.5
Â  Â  for y in [-1.5, -0.5, 0.5, 1.5]:
Â  Â  Â  Â  ax.axhline(y=y, color='black', linestyle='--', alpha=0.3)
Â  Â  ax.axhline(y=0, color='black', linestyle='-', alpha=0.5)
Â  Â Â 
Â  Â  # AnotaÃ§Ãµes dos quadrantes (Apenas um exemplo das 4 principais categorias para economizar espaÃ§o)
Â  Â  ax.text(0.875, 2.5, "Fav Forte\nMuito Alto", ha='center', fontsize=8, weight='bold')
Â  Â  ax.text(0.5, 1.0, "Fav Moderado\nForte", ha='center', fontsize=8, weight='bold')
Â  Â  ax.text(-0.5, -1.0, "Under Moderado\nForte Neg.", ha='center', fontsize=8, weight='bold')
Â  Â  ax.text(-0.875, -2.5, "Under Forte\nM. Negativo", ha='center', fontsize=8, weight='bold')

Â  Â  ax.set_xlabel(f'Aggression_{side} (-1 zebra â†” +1 favorito)')
Â  Â  ax.set_ylabel(f'Momentum (M_{side[0]}) (-3.5 zebra â†” +3.5 favorito)') # Ajustado
Â  Â  ax.set_title(f'16 Quadrantes (Aggression x Momentum) - {side}')
Â  Â  ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=8)
Â  Â  ax.grid(True, alpha=0.3)
Â  Â  ax.set_ylim(-3.5, 3.5) # Limitar o eixo Y para a escala do Z-Score
Â  Â  ax.set_xlim(-1.0, 1.0)
Â  Â Â 
Â  Â  plt.tight_layout()
Â  Â  return fig

# Exibir grÃ¡ficos
st.markdown("### ğŸ“ˆ VisualizaÃ§Ã£o dos 16 Quadrantes (Aggression x Momentum)")
col1, col2 = st.columns(2)
# Filtrar dados nulos para plotagem
df_plot_filtered = games_today.dropna(subset=['Aggression_Home', 'Aggression_Away', 'M_H', 'M_A'])

with col1:
Â  Â  st.pyplot(plot_quadrantes_16(df_plot_filtered, "Home"))
with col2:
Â  Â  st.pyplot(plot_quadrantes_16(df_plot_filtered, "Away"))

# ---------------- VISUALIZAÃ‡ÃƒO INTERATIVA (ADAPTADO) ----------------

st.markdown("## ğŸ¯ VisualizaÃ§Ã£o Interativa â€“ DistÃ¢ncia entre Times (Aggression x Momentum)")

# Filtros interativos (mantidos)
if "League" in games_today.columns and not games_today["League"].isna().all():
Â  Â  leagues = sorted(games_today["League"].dropna().unique())
Â  Â  selected_league = st.selectbox(
Â  Â  Â  Â  "Selecione a liga para anÃ¡lise:",
Â  Â  Â  Â  options=["âš½ Todas as ligas"] + leagues,
Â  Â  Â  Â  index=0
Â  Â  )

Â  Â  if selected_league != "âš½ Todas as ligas":
Â  Â  Â  Â  df_filtered = games_today[games_today["League"] == selected_league].copy()
Â  Â  else:
Â  Â  Â  Â  df_filtered = games_today.copy()
else:
Â  Â  st.warning("âš ï¸ Nenhuma coluna de 'League' encontrada â€” exibindo todos os jogos.")
Â  Â  df_filtered = games_today.copy()

# Controle de nÃºmero de confrontos (mantido)
max_n = len(df_filtered)
n_to_show = st.slider("Quantos confrontos exibir (Top por distÃ¢ncia):", 10, min(max_n, 200), 40, step=5)

# Preparar dados
df_plot = df_filtered.dropna(subset=["Quadrant_Dist"]).nlargest(n_to_show, "Quadrant_Dist").reset_index(drop=True)

# Criar grÃ¡fico Plotly
fig = go.Figure()

# Vetores Home â†’ Away
for _, row in df_plot.iterrows():
Â  Â  xh, xa = row["Aggression_Home"], row["Aggression_Away"]
Â  Â  # Eixo Y agora Ã© M_H e M_A
Â  Â  yh, ya = row["M_H"], row["M_A"]

Â  Â  fig.add_trace(go.Scatter(
Â  Â  Â  Â  x=[xh, xa],
Â  Â  Â  Â  y=[yh, ya],
Â  Â  Â  Â  mode="lines+markers",
Â  Â  Â  Â  line=dict(color="gray", width=1),
Â  Â  Â  Â  marker=dict(size=5),
Â  Â  Â  Â  hoverinfo="text",
Â  Â  Â  Â  hovertext=(
Â  Â  Â  Â  Â  Â  f"<b>{row['Home']} vs {row['Away']}</b><br>"
Â  Â  Â  Â  Â  Â  f"ğŸ† {row.get('League','N/A')}<br>"
Â  Â  Â  Â  Â  Â  f"ğŸ¯ Home: {QUADRANTES_MOMENTUM_16.get(row['Quadrante_Home'], {}).get('nome', 'N/A')}<br>"
Â  Â  Â  Â  Â  Â  f"ğŸ¯ Away: {QUADRANTES_MOMENTUM_16.get(row['Quadrante_Away'], {}).get('nome', 'N/A')}<br>"
Â  Â  Â  Â  Â  Â  f"ğŸ“ DistÃ¢ncia: {row['Quadrant_Dist']:.2f}"
Â  Â  Â  Â  ),
Â  Â  Â  Â  showlegend=False
Â  Â  ))

# Pontos Home e Away
fig.add_trace(go.Scatter(
Â  Â  x=df_plot["Aggression_Home"],
Â  Â  y=df_plot["M_H"],
Â  Â  mode="markers+text",
Â  Â  name="Home",
Â  Â  marker=dict(color="royalblue", size=8, opacity=0.8),
Â  Â  text=df_plot["Home"],
Â  Â  textposition="top center",
Â  Â  hoverinfo="skip"
))

fig.add_trace(go.Scatter(
Â  Â  x=df_plot["Aggression_Away"],
Â  Â  y=df_plot["M_A"],
Â  Â  mode="markers+text",
Â  Â  name="Away",
Â  Â  marker=dict(color="orangered", size=8, opacity=0.8),
Â  Â  text=df_plot["Away"],
Â  Â  textposition="top center",
Â  Â  hoverinfo="skip"
))

# Layout
titulo = f"Top {n_to_show} DistÃ¢ncias â€“ 16 Quadrantes (Aggression x Momentum)"
if selected_league != "âš½ Todas as ligas":
Â  Â  titulo += f" | {selected_league}"

fig.update_layout(
Â  Â  title=titulo,
Â  Â  xaxis_title="Aggression (-1 zebra â†” +1 favorito)",
Â  Â  yaxis_title="Momentum (M) (-3.5 zebra â†” +3.5 favorito)", # Ajustado
Â  Â  template="plotly_white",
Â  Â  height=700,
Â  Â  hovermode="closest",
Â  Â  legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
)
# Limitar eixos
fig.update_xaxes(range=[-1.0, 1.0])
fig.update_yaxes(range=[-3.5, 3.5])


st.plotly_chart(fig, use_container_width=True)

# ---------------- MODELO ML ATUALIZADO PARA 16 QUADRANTES (MOMENTUM) ----------------
# Adicionando cache para nÃ£o retreinar a cada interaÃ§Ã£o
@st.cache_resource
def treinar_modelo_quadrantes_16_dual(history, games_today):
Â  Â  """
Â  Â  Treina modelo ML para Home e Away com base nos 16 quadrantes (Aggression x M)
Â  Â  """
Â  Â  # Garantir cÃ¡lculo das distÃ¢ncias
Â  Â  history = calcular_distancias_quadrantes(history)
Â  Â  games_today = calcular_distancias_quadrantes(games_today)

Â  Â  # Preparar features bÃ¡sicas
Â  Â  # Os dummies sÃ£o gerados com base na nova classificaÃ§Ã£o Aggression x M
Â  Â  quadrantes_home = pd.get_dummies(history['Quadrante_Home'], prefix='QH')
Â  Â  quadrantes_away = pd.get_dummies(history['Quadrante_Away'], prefix='QA')
Â  Â  ligas_dummies = pd.get_dummies(history['League'], prefix='League')

Â  Â  # Features contÃ­nuas (incluindo M_H e M_A, alÃ©m das mÃ©tricas de distÃ¢ncia)
Â  Â  # Note que M_H/M_A jÃ¡ sÃ£o Z-Scores, o que Ã© Ã³timo para o ML.
Â  Â  extras = history[['Quadrant_Dist', 'Quadrant_Separation', 'Quadrant_Angle', 'M_H', 'M_A']].fillna(0)

Â  Â  # Combinar todas as features
Â  Â  X = pd.concat([quadrantes_home, quadrantes_away, ligas_dummies, extras], axis=1)

Â  Â  # Targets
Â  Â  y_home = history['Target_AH_Home']
Â  Â  y_away = 1 - y_homeÂ  # inverso lÃ³gico

Â  Â  # Treinar modelos (mantidas as configuraÃ§Ãµes originais do RF)
Â  Â  model_home = RandomForestClassifier(
Â  Â  Â  Â  n_estimators=500, max_depth=12, random_state=42, class_weight='balanced_subsample', n_jobs=-1
Â  Â  )
Â  Â  model_away = RandomForestClassifier(
Â  Â  Â  Â  n_estimators=500, max_depth=12, random_state=42, class_weight='balanced_subsample', n_jobs=-1
Â  Â  )
    
    # Garantir que o X nÃ£o esteja vazio
    if X.empty or y_home.empty:
        st.error("âŒ Dados insuficientes para treinar o modelo apÃ³s os filtros.")
        return None, None, games_today
    
    # Garantir que todas as colunas sejam float/int antes do fit
    X = X.select_dtypes(include=np.number)


Â  Â  model_home.fit(X, y_home)
Â  Â  model_away.fit(X, y_away)

Â  Â  # Preparar dados para hoje
Â  Â  # Reindex para garantir que as dummies de hoje tenham as mesmas colunas das dummies de treino
Â  Â  qh_today = pd.get_dummies(games_today['Quadrante_Home'], prefix='QH').reindex(columns=quadrantes_home.columns, fill_value=0)
Â  Â  qa_today = pd.get_dummies(games_today['Quadrante_Away'], prefix='QA').reindex(columns=quadrantes_away.columns, fill_value=0)
Â  Â  ligas_today = pd.get_dummies(games_today['League'], prefix='League').reindex(columns=ligas_dummies.columns, fill_value=0)
Â  Â  # Features contÃ­nuas de hoje
Â  Â  extras_today = games_today[['Quadrant_Dist', 'Quadrant_Separation', 'Quadrant_Angle', 'M_H', 'M_A']].fillna(0)

Â  Â  X_today = pd.concat([qh_today, qa_today, ligas_today, extras_today], axis=1)
    
    # Garantir que X_today tenha as mesmas colunas de X na mesma ordem
    X_today = X_today.reindex(columns=X.columns, fill_value=0)

Â  Â  # Fazer previsÃµes
Â  Â  probas_home = model_home.predict_proba(X_today)[:, 1]
Â  Â  probas_away = model_away.predict_proba(X_today)[:, 1]

Â  Â  games_today['Quadrante_ML_Score_Home'] = probas_home
Â  Â  games_today['Quadrante_ML_Score_Away'] = probas_away
Â  Â  games_today['Quadrante_ML_Score_Main'] = np.maximum(probas_home, probas_away)
Â  Â  games_today['ML_Side'] = np.where(probas_home > probas_away, 'HOME', 'AWAY')

Â  Â  # Mostrar importÃ¢ncia das features
Â  Â  try:
Â  Â  Â  Â  importances = pd.Series(model_home.feature_importances_, index=X.columns).sort_values(ascending=False)
Â  Â  Â  Â  top_feats = importances.head(15)
Â  Â  Â  Â  st.markdown("### ğŸ” Top Features mais importantes (Modelo HOME - Aggression x Momentum)")
Â  Â  Â  Â  st.dataframe(top_feats.to_frame("ImportÃ¢ncia"), use_container_width=True)
Â  Â  except Exception as e:
Â  Â  Â  Â  st.warning(f"NÃ£o foi possÃ­vel calcular importÃ¢ncias: {e}")

Â  Â  st.success("âœ… Modelo dual (Home/Away) com 16 quadrantes (Aggression x M) treinado com sucesso!")
Â  Â  return model_home, model_away, games_today

# ---------------- EXECUÃ‡ÃƒO PRINCIPAL ----------------
# Executar treinamento
if not history.empty and 'M_H' in history.columns and 'Aggression_Home' in history.columns:
Â  Â  modelo_home, modelo_away, games_today = treinar_modelo_quadrantes_16_dual(history, games_today)
else:
Â  Â  st.warning("âš ï¸ HistÃ³rico vazio ou colunas Aggression/M_H/M_A ausentes - nÃ£o foi possÃ­vel treinar o modelo")

# ---------------- SISTEMA DE INDICAÃ‡Ã•ES (ADAPTADO) ----------------
# Garantir que o resultado do ML exista antes de continuar
if 'Quadrante_ML_Score_Main' in games_today.columns:

    def adicionar_indicadores_explicativos_16_dual(df):
Â  Â      """Adiciona classificaÃ§Ãµes e recomendaÃ§Ãµes explÃ­citas para 16 quadrantes (Agg x M)"""
Â  Â      df = df.copy()
Â  Â Â 
Â  Â      # Mapear quadrantes para labels (usando o novo dicionÃ¡rio)
Â  Â      df['Quadrante_Home_Label'] = df['Quadrante_Home'].map(lambda x: QUADRANTES_MOMENTUM_16.get(x, {}).get('nome', 'Neutro'))
Â  Â      df['Quadrante_Away_Label'] = df['Quadrante_Away'].map(lambda x: QUADRANTES_MOMENTUM_16.get(x, {}).get('nome', 'Neutro'))
Â  Â Â 
Â  Â      # 1. CLASSIFICAÃ‡ÃƒO DE VALOR PARA HOME (mantida a lÃ³gica de score)
Â  Â      conditions_home = [
Â  Â  Â  Â      df['Quadrante_ML_Score_Home'] >= 0.65,
Â  Â  Â  Â      df['Quadrante_ML_Score_Home'] >= 0.58,
Â  Â  Â  Â      df['Quadrante_ML_Score_Home'] >= 0.52,
Â  Â  Â  Â      df['Quadrante_ML_Score_Home'] >= 0.48,
Â  Â  Â  Â      df['Quadrante_ML_Score_Home'] < 0.48
Â  Â      ]
Â  Â      choices_home = ['ğŸ† ALTO VALOR', 'âœ… BOM VALOR', 'âš–ï¸ NEUTRO', 'âš ï¸ CAUTELA', 'ğŸ”´ ALTO RISCO']
Â  Â      df['Classificacao_Valor_Home'] = np.select(conditions_home, choices_home, default='âš–ï¸ NEUTRO')
Â  Â Â 
Â  Â      # 2. CLASSIFICAÃ‡ÃƒO DE VALOR PARA AWAY (mantida a lÃ³gica de score)
Â  Â      conditions_away = [
Â  Â  Â  Â      df['Quadrante_ML_Score_Away'] >= 0.65,
Â  Â  Â  Â      df['Quadrante_ML_Score_Away'] >= 0.58,
Â  Â  Â  Â      df['Quadrante_ML_Score_Away'] >= 0.52,
Â  Â  Â  Â      df['Quadrante_ML_Score_Away'] >= 0.48,
Â  Â  Â  Â      df['Quadrante_ML_Score_Away'] < 0.48
Â  Â      ]
Â  Â      choices_away = ['ğŸ† ALTO VALOR', 'âœ… BOM VALOR', 'âš–ï¸ NEUTRO', 'âš ï¸ CAUTELA', 'ğŸ”´ ALTO RISCO']
Â  Â      df['Classificacao_Valor_Away'] = np.select(conditions_away, choices_away, default='âš–ï¸ NEUTRO')
Â  Â Â 
Â  Â      # 3. RECOMENDAÃ‡ÃƒO DE APOSTA DUAL (LÃ³gica de strings adaptada para o novo nome)
Â  Â      def gerar_recomendacao_16_dual(row):
Â  Â  Â  Â      home_q = row['Quadrante_Home_Label']
Â  Â  Â  Â      away_q = row['Quadrante_Away_Label']
Â  Â  Â  Â      score_home = row['Quadrante_ML_Score_Home']
Â  Â  Â  Â      score_away = row['Quadrante_ML_Score_Away']
Â  Â  Â  Â      ml_side = row['ML_Side']
Â  Â  Â  Â Â 
Â  Â  Â  Â      # AdaptaÃ§Ã£o dos padrÃµes especÃ­ficos para "M_Muito Alto" e "M_Muito Neg."
Â  Â  Â  Â      if 'Fav Forte' in home_q and 'M_Muito Alto' in home_q and 'M_Muito Neg.' in away_q:
Â  Â  Â  Â  Â  Â      return f'ğŸ’ª FAVORITO HOME FORTE (MOMENTUM) ({score_home:.1%})'
Â  Â  Â  Â      elif 'Fav Forte' in away_q and 'M_Muito Alto' in away_q and 'M_Muito Neg.' in home_q:
Â  Â  Â  Â  Â  Â      return f'ğŸ’ª FAVORITO AWAY FORTE (MOMENTUM) ({score_away:.1%})'
Â  Â  Â  Â      elif ml_side == 'HOME' and score_home >= 0.60:
Â  Â  Â  Â  Â  Â      return f'ğŸ“ˆ MODELO CONFIA HOME ({score_home:.1%})'
Â  Â  Â  Â      elif ml_side == 'AWAY' and score_away >= 0.60:
Â  Â  Â  Â  Â  Â      return f'ğŸ“ˆ MODELO CONFIA AWAY ({score_away:.1%})'
Â  Â  Â  Â      elif 'M_Moderado' in home_q and score_away >= 0.58:
Â  Â  Â  Â  Â  Â      return f'ğŸ”„ AWAY EM MODERADO ({score_away:.1%})'
Â  Â  Â  Â      elif 'M_Moderado' in away_q and score_home >= 0.58:
Â  Â  Â  Â  Â  Â      return f'ğŸ”„ HOME EM MODERADO ({score_home:.1%})'
Â  Â  Â  Â      else:
Â  Â  Â  Â  Â  Â      return f'âš–ï¸ ANALISAR (H:{score_home:.1%} A:{score_away:.1%})'
Â  Â Â 
Â  Â      df['Recomendacao'] = df.apply(gerar_recomendacao_16_dual, axis=1)
Â  Â Â 
Â  Â      # 4. RANKING POR MELHOR PROBABILIDADE
Â  Â      df['Ranking'] = df['Quadrante_ML_Score_Main'].rank(ascending=False, method='dense').astype(int)
Â  Â Â 
Â  Â      return df

    games_today = adicionar_indicadores_explicativos_16_dual(games_today)

    # ... (Restante das funÃ§Ãµes: analisar_padroes_quadrantes_16_dual, gerar_estrategias_16_quadrantes, calcular_pontuacao_quadrante_16, gerar_score_combinado_16)
    # ... (Estas funÃ§Ãµes devem ser adaptadas para usar QUADRANTES_MOMENTUM_16, M_H, M_A, etc.)

    # ---------------- VISUALIZAÃ‡ÃƒO DOS RESULTADOS FINAIS (Tabela) ----------------
    st.markdown("### ğŸ¥‡ Principais IndicaÃ§Ãµes (Ranking pelo Modelo)")
    cols_display = [
        'Ranking', 'Home', 'Away', 'League', 'Asian_Line_Decimal', 'M_H', 'M_A',
        'Aggression_Home', 'Aggression_Away', 'Quadrante_Home_Label', 'Quadrante_Away_Label',
        'Quadrant_Dist', 'Quadrante_ML_Score_Main', 'ML_Side', 'Recomendacao'
    ]

    # Ordenar e exibir o DataFrame
    df_final = games_today.sort_values("Ranking", ascending=True)

    st.dataframe(
        df_final[[c for c in cols_display if c in df_final.columns]].head(50)
        .style.format({
            'Asian_Line_Decimal': '{:.2f}',
            'M_H': '{:.2f}',
            'M_A': '{:.2f}',
            'Aggression_Home': '{:.2f}',
            'Aggression_Away': '{:.2f}',
            'Quadrant_Dist': '{:.2f}',
            'Quadrante_ML_Score_Main': '{:.1%}'
        })
        .background_gradient(subset=['Quadrante_ML_Score_Main'], cmap='RdYlGn'),
        use_container_width=True
    )

# ... (Se necessÃ¡rio, vocÃª pode adicionar a lÃ³gica adaptada das outras funÃ§Ãµes aqui)
